package slice

/* comparable的定义
comparable 是 Go 语言中的一个内置约束（type constraint），用于泛型编程。
只有支持 == 和 != 操作符的类型才属于 comparable 类型，包括：
- 所有基础类型（如 int、float、string、bool 等）
- 指针、通道、接口（只要其底层类型可比较）
- 数组（元素类型也必须是 comparable）
- 结构体（所有字段都必须是 comparable）
不能比较的类型（如切片、map、函数等）不能用作 comparable。
在泛型函数中，使用 comparable 作为类型参数约束，可以保证该类型的值可以进行相等性比较。
例如：
func Equal[T comparable](a, b T) bool { return a == b }
*/

// 交集（Intersection）的常见实现方法：
// 1. 哈希表法：
//    - 先将第一个集合（如切片 a）中的所有元素放入一个 map（哈希表）中，记录出现次数或标记存在。
//    - 然后遍历第二个集合（切片 b），对于每个元素，判断其是否在 map 中出现过，若出现则加入结果集。
//    - 这种方法时间复杂度为 O(n+m)，空间复杂度为 O(n)，适用于元素可哈希且集合较大时。
// 2. 双指针法（适用于有序集合）：
//    - 先对两个集合排序，然后用两个指针分别遍历两个集合，遇到相等的元素则加入结果集，指针同步前进。
//    - 时间复杂度为 O(nlogn + mlogm)（排序）+ O(n+m)（遍历），空间复杂度为 O(1) 或 O(n+m)。
//    - 适用于集合已排序或可以排序的场景。
// 3. 暴力法：
//    - 对于集合 a 的每个元素，遍历集合 b，判断是否存在相等元素，若存在则加入结果集。
//    - 时间复杂度为 O(n*m)，效率较低，仅适用于数据量很小的场景。
// 在 Go 语言泛型实现中，通常采用哈希表法，利用 map[T]struct{} 来高效判断元素是否存在。

// 交集，(A ∩ B)，用于找出两个集合中共同的元素。
func Intersection[T comparable](a, b []T) []T {
	ans := []T{}
	mp := make(map[T]struct{})
	for _, v := range a {
		mp[v] = struct{}{}
	}

	for _, v := range b {
		if _, ok := mp[v]; ok {
			ans = append(ans, v)
		}
	}
	return ans
}

// 并集（Union）的常见实现方法：
// 1. 哈希表法：
//    - 先将第一个集合（如切片 a）中的所有元素放入一个 map（哈希表）中，标记存在。
//    - 再遍历第二个集合（切片 b），将不在 map 中的元素加入 map。
//    - 最后将 map 的所有 key 转为切片作为结果。
//    - 时间复杂度 O(n+m)，空间复杂度 O(n+m)，适用于元素可哈希且集合较大时。
// 2. 直接合并去重法：
//    - 先将 a 和 b 合并为一个切片，然后用 map 去重。
//    - 适合数据量不大、对顺序无要求的场景。
// 3. 排序+去重法（适用于有序集合）：
//    - 先合并两个集合，排序后遍历去重。
//    - 时间复杂度 O((n+m)log(n+m))，空间复杂度 O(n+m)。
//    - 适用于集合已排序或可以排序的场景。
// 在 Go 语言泛型实现中，通常采用哈希表法，利用 map[T]struct{} 来高效去重，得到并集。

// 并集，(A ∪ B)，用于找出两个集合中所有的元素。
func Union[T comparable](a, b []T) []T {
	ans := []T{}
	mp := make(map[T]struct{}) // map+空字结构体作为value，当作set使用
	for _, v := range a {
		mp[v] = struct{}{} // 标记a中存在的元素
	}
	for _, v := range b {
		mp[v] = struct{}{} // 标记b中存在的元素
	}

	// 遍历mp，将所有元素加入结果集
	for k := range mp {
		ans = append(ans, k)
	}
	return ans
}

// 差集（Difference）的常见实现方法：
// 1. 哈希表法：
//    - 先将第二个集合（如切片 b）中的所有元素放入一个 map（哈希表）中，标记存在。
//    - 然后遍历第一个集合（切片 a），对于每个元素，判断其是否在 map 中不存在，若不存在则加入结果集。
//    - 这种方法时间复杂度为 O(n+m)，空间复杂度为 O(m)，适用于元素可哈希且集合较大时。
// 2. 暴力法：
//    - 对于集合 a 的每个元素，遍历集合 b，判断是否存在相等元素，若不存在则加入结果集。
//    - 时间复杂度为 O(n*m)，效率较低，仅适用于数据量很小的场景。
// 3. 排序+双指针法（适用于有序集合）：
//    - 先对两个集合排序，然后用两个指针分别遍历两个集合，遇到相等的元素则跳过，否则将 a 中未在 b 中出现的元素加入结果集。
//    - 时间复杂度 O(nlogn + mlogm)（排序）+ O(n+m)（遍历），空间复杂度 O(1) 或 O(n+m)。
// 在 Go 语言泛型实现中，通常采用哈希表法，利用 map[T]struct{} 来高效判断元素是否存在，从而得到差集。

// 差集，(A - B)，用于找出在A中但不在B中的元素。
func Difference[T comparable](a, b []T) []T {
	ans := []T{}
	mp := make(map[T]struct{}) // map+空字结构体作为value，当作set使用
	for _, v := range b {
		mp[v] = struct{}{} // 标记b中存在的元素
	}
	for _, v := range a {
		if _, ok := mp[v]; !ok { // 如果a中元素在b中不存在，则加入结果集
			ans = append(ans, v)
		}
	}
	return ans
}

// 常见的求对称差集（Symmetric Difference）的方法有以下几种：
// 1. 哈希表法：
//    - 分别将 a 和 b 的所有元素放入两个 map（哈希表）中。
//    - 遍历 a，将不在 b 中的元素加入结果集；遍历 b，将不在 a 中的元素也加入结果集。
//    - 时间复杂度 O(n+m)，空间复杂度 O(n+m)，适用于元素可哈希且集合较大时。
// 2. 并集-交集法：
//    - 先求 a 和 b 的并集，再求交集，最后用并集减去交集，得到对称差集。
//    - 适合已有并集和交集实现的场景。
// 3. 排序+双指针法（适用于有序集合）：
//    - 先对 a 和 b 排序，然后用两个指针分别遍历，遇到相等的元素跳过，不等的元素加入结果集。
//    - 时间复杂度 O(nlogn + mlogm)（排序）+ O(n+m)（遍历），空间复杂度 O(1) 或 O(n+m)。
// 在 Go 语言泛型实现中，通常采用哈希表法，利用 map[T]struct{} 来高效判断元素是否存在，从而得到对称差集。

// 对称差集，(A - B) ∪ (B - A)，用于找出两个集合之间不重叠的部分。
func SymmetricDifference[T comparable](a, b []T) []T {
	// 遍历a，将a中有，但b中没有的元素加入到结果集中
	// 遍历b，将b中有，但a中没有的元素加入到结果集中
	ans := Difference(a, b)
	ans = append(ans, Difference(b, a)...)
	return ans
}
